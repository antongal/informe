\chapter{Preliminares}

En esta secci'on se explicar'an los conceptos b'asicos necesarios para entender este trabajo. En particular se va a hablar de los lenguajes \textit{Alloy} y \textit{TPTP-FOF}, el c'alculo de secuentes y el c'alculo por superposici'on, demostraciones heterogeneas y las herramientas utilizadas en 'esta tesis como lo son \textit{AlloyAnalyzer}, \textit{E-Prover}, \textit{SPASS}, \textit{Mace4} y \textit{Heterogenius}. 

En el resto del texto se utilizar'an letras griegas en min'uscula para referirnos a f'ormulas y las letras griegas may'usculas para representar conjuntos o listas de f'ormulas.

\input{alloy}

\input{calc_secuentes}

\input{demo_heterogeneas}


\section{Heterogenius}

Heterogenius \cite{heterogenius} es un demostrador de teoremas heterog'eneo que, como su principal objetivo, permite realizar demostraciones interactivas mediante el c'alculo de secuentes, representando lo que se quiere demostrar en distintos lenguajes, aplicando reglas de ese c'alculo y usando herramientas autom'aticas externas. 

Su principal caracter'istica es que soporta demostraciones heterog'eneas. En otras palabras las demostraciones pueden realizarse utilizando secuentes escritos en distintos lenguajes. Los lenguajes soportados actualmente son dos: \textit{Alloy} \cite{alloy} y \textit{PDOCFA} \cite{pdocfa}. Entre otras, Heterogenius presenta las siguientes caracter'isticas:

\begin{itemize}

\item Pone en pr'actica la idea de \textit{'arbol de an'alisis} el cu'al es el elemento principal donde se realiza el proceso de demostraci'on.

\item Separa conceptualmente y arquitect'onicamente las herramientas utilizadas durante el an'alisis.

\item Ofrece interacci'on con varias herramientas externas.

\item Posee una arquitectura modular y extensible.

\item Posee una interfaz de usuario moderna que intenta ser más intuitiva que las interfaces textuales que aún son la tendencia predominante en los sistemas de demostración interactivos.

\end{itemize}

Debido a la extensibilidad fue uno de los conceptos que guiaron su diseño, Heterogenius sirve como  una plataforma en la cu'al se puede experimentar con lenguajes y herramientas autom'aticas nuevas.


\section{TPTP-FOF}

\textit{TPTP} (mil problemas para demostradores autom'aticos, por sus siglas en ingles) \cite{tptp} es una biblioteca de problemas para demostradores autom'aticos de teoremas. La principal motivaci'on para \textit{TPTP} es permitir el testeo y evaluaci'on de diferentes sistemas de demostradores autom'aticos de teoremas. Los problemas est'an en cuatro lenguajes: \textit{THF}, \textit{TFF}, \textit{FOF} y \textit{CNF}.

Anualmente se realiza la competencia \textit{CASC} (CADE ATP System Competition \cite{casc}), una competencia de demostradores autom'aticos de teoremas donde los sistemas participanetes compiten para probar la mayor cantidad de problemas de \textit{TPTP}. 'Esta competencia resulta una muy buena prueba para evaluar el funcionamiento de las herramientas autom'aticas disponibles.

\textit{FOF} \cite{fof} es un lenguaje de l'ogica de primer 'orden con igualdad. Su elecci'on de \textit{FOF} est'a motivada  por su difundido uso y soporte que tiene de las herramientas autom'aticas y su expresividad a nivel de sintaxis. Una especificaci'on de \textit{TPTP-FOF} es una lista de f'ormulas que adem'as tienen un nombre y un tipo. Por ejemplo:

\begin{verbatim}
fof(john,axiom,( 
    human(john) )).

fof(all_created_equal,axiom,( 
    ! [H1,H2] : 
      ( ( human(H1) 
         & human(H2) ) 
     => created_equal(H1,H2) ) )). 

fof(john_failed,axiom,( 
    grade(john) = f )). 

fof(someone_got_an_a,axiom,( 
    ? [H] : 
      ( human(H) 
      & grade(H) = a ) )). 

fof(distinct_grades,axiom,( 
    a != f )). 

fof(grades_not_human,axiom,( 
    ! [G] : ~ human(grade(G)) )). 

fof(someone_not_john,conjecture,( 
    ? [H] : 
      ( human(H) 
      & H != john ) )). 
\end{verbatim}

Especificaci'on t'ipica en el lenguaje \textit{TPTP-FOF}. La sintaxis contiene todos los elementos de la l'ogica de primer 'orden. \textbf{![X]} es el cuantificador universal sobre la variable \textit{X}; \textbf{?[X]} es el cuantificador existencial sobre la variable \textit{X}. \textit{$human()$}, \textit{$grade()$}, \textit{$created\_equal()$} son predicados; las variables empiezan con una letra mayuscula y las constantes con minuscula. Los operadores disponibles son $\sim$, $|$, $\&$, $=>$, $<=>$, $=$ y $!=$ y corresponden con la negaci'on, la disyunci'on, la conjunci'on, la implicaci'on, la doble implicaci'on, la igualdad y la desigualdad.

En el ejemplo anterior la 'ultima f'ormula es de tipo \textit{conjecture}. 'Esto indica al demostrador que es la f'ormula que se quiere probar. Las otras f'ormulas, de tipo \textit{axiom} se interpretan como axiomas.


\section{C'alculo por superposici'on}
Es un c'alculo que permite razonar en l'ogica de primer 'orden. Se ha desarrollado a principios de 1990 y combina los principios de resoluci'on de primer 'orden con el manejo de igualdad basada en 'orden desarrollado en el contexto del algoritmo de completitud de \textit{Knuth-Bendix}\cite{knuthbendix}. Como la mayoria de calculos de l'ogica de primer 'orden, superposici'on trata de mostrar la insatisfacibilidad de un conjunto de clausulas realizando demostraciones por refutaci'on. Superposici'on es completo para la refutaci'on, o sea dada una cantidad ilimitada de recursos y una estrategia de derivaci'on justa, se va a llegar a una contradicci'on empezando por cualquier conjunto de clausulas insatisfacible.


\section{E-Prover}
E-Prover es un demostrador de teoremas de l'ogica de primer orden con igualdad. Se basa en el c'alculo por superposici'on. El demostrador acepta como entrada una lista de clausulas o f'ormulas de l'ogica de primer orden con una conjetura. El sistema intenta encontrar una demostraci'on para la conjetura asumiendo los axiomas especificados.

Ya que E-Prover adem'as permite buscar un modelo se lo puede utilizar tambi'en como un buscador de contraejemplos.

Internamente la principal t'ecnica usada es el c'alculo por superposici'on. El demostrador opera en cuatro fases distintas:
\begin{itemize}
\item Clausificaci'on: se transforman las f'ormulas de entrada en f'orma normal clausal de tal manera que la f'ormula resultante es insatisfacible si y s'olo si el problema original es demostrable. Se usa una variaci'on del algoritmo detallado en \cite{smallcnf2001}.

\item Una etapa opcional de simplificaci'on de la forma clausal del problema.

\item An'alisis del problema y selecci'on de par'ametros 'optimos para la b'usqueda.

\item La etapa de saturaci'on que se implementa sobre un algoritmo del c'alculo de superposici'on descripto en \cite{bg94} y \cite{aicom2002} que trata de encontrar la cl'ausula vac'ia, lo que permite determinar que la cl'ausula original es insatisfacible y, por lo tanto, el problema de entrada es demostrable. E-Prover implementa el algoritmo de superposici'on con selecci'on del literal negativo y con factorizaci'on de igualdad. Se incorporan varias t'ecnicas de simplificaci'on como por ejemplo reescritura incondicional, subsunci'on, eliminaci'on de tautologias semanticas y corte de literales contextuales. Tambi'en se implementa la eliminaci'on de redundancia AC documentada en \cite{jsc2003} y la introducci'on controlada de definiciones para partes independientes de cl'ausulas \cite{ijcai2001}.
\end{itemize}

\subsection{B'usqueda de demostraci'on}

E-Prover utiliza una variante del algoritmo de ``cl'ausula dada'' \cite{dk97}. El estado de la demostraci'on se representa por dos conjuntos de cl'ausulas: el conjunto \textbf{P} de cl'ausulas procesadas (inicialmente vac'io) y el conjunto \textbf{U} de cl'ausulas sin procesar. Las cl'ausulas en \textbf{U} se ordenan de acuerdo a una funci'on de evaluaci'on he'uristica y se procesan en ese orden.

El procesamiento primero simplifica la cl'ausula seleccionada \textit{g} con todas las cl'ausulas en \textbf{P}, luego simplifica \textbf{P} con \textit{g}, moviendo todas las cl'ausulas afectadas desde \textbf{P} a \textbf{U}. Luego se computan todas las consecuencias directas entre \textit{g} y \textbf{P} que pueden ser derivadas utilizando las reglas de inferencia (superposici'on, factoreo de igualdad y resoluci'on de igualdad). Las nuevas cl'ausulas son simplificadas respecto a \textbf{P} y son agregadas a \textbf{U}, a su vez \textit{g} es agregado a \textbf{P}.

Este procedimiento de b'usqueda de demostraci'on es diferente del algoritmo de ``cl'ausula dada'' implementado por \texttt{Otter} y otros demostradores que tambi'en utilizan el conjunto \textbf{U} para la simplificaci'on. 'Esta variante tambi'en se utiliza en \texttt{Waldmeister} y forma parte adem'as del algoritmo principal de \texttt{Vampire} y \texttt{SPASS}.

\subsection{Heur'isticas}

E-Prover usa una serie de heur'isticas para: la elecci'on del ordenamiento de t'erminos que restringe las inferencias y controla la reescritura; la elecci'on de la siguiente cl'ausula de \textbf{U} y opcionalmente la elecci'on de literales para la inferencia en las cl'ausulas que tienen por lo menos un literal negativo.

La selecci'on de las cl'ausulas dadas es controlada por varias colas de prioridad de las cuales se seleccionan las cl'ausulas en un esquema ``round robin pesado''. Cada cola es ordenada de acuerdo a una funci'on de prioridad fija y una funci'on de evaluaci'on de cl'ausula parametrizada. Las funciones de evaluaci'on de cl'ausulas pueden ser orientadas a objetivos, pueden estar enfocadas en algunos s'imbolos en particular y pueden tomar en cuenta el ordenamiento de t'erminos. 


La selecci'on de literales es controlada por una de las cien estrategias de selecci'on que est'an codificadas en E-Prover. En el modo autom'atico el demostrador selecciona una de ellas.




\section{SPASS}

SPASS es un demostrador autom'atico de teoremas basado en saturaci'on para l'ogica de primer orden con igualdad. Como se menciona en la descripci'on oficial, SPASS es 'unico debido a que combina el c'alculo de superposici'on con reglas espec'ificas de inferencia/reducci'on para tipos y una regla de partici'on para an'alisis de casos motivada por la regla $\beta$ del m'etodo de \textit{tableau} anal'itico y el an'alisis de casos empleado en el procedimiento \textit{Davis-Putnam}. El 'enfasis de SPASS est'a puesto en las diferentes t'ecnicas de inferencia, reducci'on, simplificaci'on, y no as'i en las heur'isticas.

Todo el funcionamiento interno de SPASS est'a basado en l'ogica de primer 'orden y consiste en reglas de inferencia que generan nuevas cl'ausulas y reglas de reducci'on que reducen la cantidad de cl'ausulas o las simplifican. Hay una gran variedad de reglas de inferencia y reducci'on para conjuntos de cl'ausulas que pueden ser combinadas para ajustarse a varios c'alculos de primer orden completos y correctos. La particularidad de SPASS es que se introduce una regla nueva que es la regla de partici'on que soporta un an'alisis de casos expl'icito. De 'esta manera la regla de partici'on introduce una segunda dimensi'on en el m'etodo de demostraci'on de teoremas basado en saturaci'on.

La tercera dimensi'on que se considera en SPASS son las restricciones, informaci'on extra que se adjunta a las cl'ausulas restrigiendo su sem'antica y su uso respecto al c'alculo. Algunas de las restriciones son \textit{de orden}, forzando que los t'erminos substituidos satisfagan las funciones de restricci'on adjuntas y restricciones \textit{de tipo} que garantizan que la instanciaci'on de las variables corresponda al tipo especificado.


\section{Mace4}

Mace4 es un buscador de modelos finitos basado en \textit{backtracking} y puede ser considerado una variaci'on del algor'itmo \textit{DPLL/Davis-Putnam-Logemann-Loveland}. La principal diferencia radica en la selecci'on de celdas en la matriz que representa el modelo buscado, la selecci'on de valores a asignar y la propagaci'on de las asignaciones.

\subsection{Inicializaci'on}

Mace4 siempre hace la b'usqueda sobre un modelo de dominio finito. Incluso cuando no se especifica un tamaño de dominio Mace4 itera sobre los posibles tamaños ejecutando la rutina de b'usqueda sobre cada dominio candidato.

La inicializaci'on comienza con la creaci'on de matrices para las funciones. Para cada funci'on de aridad $k$ se crea una matriz $n^k$ donde $n$ es el tamaño del dominio.

\subsection{B'usqueda}

La b'usqueda se realiza con una recursi'on backtracking y su pseudoc'odigo es:

\begin{figure}[htbp]
\makebox[\textwidth]{}{
\small
\begin{verbatim}
procedure search:
  cell = select_cell()
  top = last_value_to_consider()
  foreach i (0 ... top)
    if (assign_and_propagate(cell,i)):
      search()
      undo_assignments();
\end{verbatim}
\normalsize}
\caption{Algor'itmo de b'usqueda utilizado en \textit{Mace4}.}
\label{fig:mace4_busqueda}
\end{figure}

Las partes m'as importantes del algor'itmo son las heuristicas de selecci'on de celdas; determinaci'on de los valores a asignar a la celda seleccionada; y propagaci'on de la asignacion.

\subsubsection{Selecci'on de celdas}

\begin{itemize}

\item{Armado del conjunto de celdas candidatas}: Existen tres heur'isticas para el armado del conjunto:

\begin{itemize}
\item Orden lineal. Se seleccionan todas las celdas abiertas.
\item Orden concentrico. Sea $i$ el 'indice m'aximo m'as chico de una celda abierta, se seleccionan todas las celdas con el 'indice $i$ m'aximo.
\item Orden de banda conc'entrica. Todas las celdas con el 'indice m'aximo menor o igual al valor actual de restricci'on son candidatas. Si no se encuentra ninguna se revierte al orden conc'entrico.
\end{itemize}


\item{Selecci'on de la celda}. Se utilizan cuatro m'etodos:

\begin{itemize}
\item{m'etodo 0}: Se selecciona la primer celda candidata.
\item{m'etodo 1}: Se selecciona la candidata con el mayor n'umero de ocurrencias en el actual conjunto de cl'ausulas.
\item{m'etodo 2}: Se selecciona la candidata que podr'ia producir el mayor n'umero de propagaciones. La motivaci'on est'a en llenar la tabla lo antes posible.
\item{m'etodo 3}: Se selecciona la candidata que podr'ia causar el mayor n'umero de contradicciones. La motivaci'on es cortar la mayor cantidad de caminos lo antes posible.
\item{m'etodo 4}: Se selecciona la candidata con la menor cantidad de valores posibles.
\end{itemize}

\end{itemize}


\subsubsection{Asignaci'on de la celda}
Una vez que se seleccionan las celdas abiertas, se debe determinar el conjunto de valores a considerar para la asignaci'on. Si se trata de una celda booleana siempre se prueba con $0$ y $1$. Si no, se prueba con todos los valores del dominio $[0,\dots,n-1]$ si no se est'a usando la heur'istica \textit{LNH} (Least Number Heuristic). Esta heur'istica fue usada por primera vez en \cite{zhang95} y \cite{zhang96} y su objetivo es tratar de eliminar alg'un isomorfismo en la b'usqueda. La idea principal es de mantener el dominio particionado en valores asimetricos y valores sim''etricos. S'olo uno de los valores sim'etricos debe ser probado. En la pr'actica esta heur'istica es efectiva en los niveles m'as altos del 'arbol de b'usqueda.


\subsubsection{Propagaci'on}

\begin{itemize}

\item{Propagaci'on Positiva}:
La propagaci'on positiva se aplica siempre al tener una asignaci'on. Por ejemplo si $f(2,3)=4$, entonces todas las ocurrencias de $f(2,3)$ pueden ser reemplazadas por $4$. Cada uno de estos reemplazos puede producir otros reemplazos en cadena. Por ejemplo $g(f(2,3))=5$ al ser reemplazado una vez termina siendo $g(4)=5$, pero esto genera una nueva asignaci'on y reemplazos posibles.

\item{Propagaci'on Negativa}:
La propagaci'on negativa tiene como objetivo reducir la cantidad de posibles valores de una asignaci'on hasta tener un solo valor que se pueda asignar. Por ejemplo sabiendo que $f(2,3)=4$ y $f(2, g(5))\neq4$ se puede inferir que $g(5)\neq3$. Los cuatro tipos de clausulas que pueden producir propagaciones negativas son:

\medskip
\begin{center}
\begin{tabular}{ |l|l| }
\hline
Tipo & Ejemplo \\
\hline
Asignaci'on & $f(2,3)=4$ \\
Casi asignaci'on & $f(2,g(5))=4$ \\
Eliminaci'on & $f(2,3)\neq4$ \\
Casi eliminaci'on & $f(2,g(5))\neq4$ \\
\hline
\end{tabular}
\end{center}
\medskip

La asignaci'on se empareja con casi eliminaci'on y la eliminaci'on con casi asignaci'on. Cualquiera de estas cuatro cl'ausulas puede producir una propagaci'on negat'iva

\end{itemize}
